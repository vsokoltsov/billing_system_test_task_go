
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pipeline: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">billing_system_test_task/internal/pipeline/pipeline.go (100.0%)</option>
				
				<option value="file1">billing_system_test_task/internal/repositories/operation.go (100.0%)</option>
				
				<option value="file2">billing_system_test_task/internal/repositories/reports/file_handler.go (100.0%)</option>
				
				<option value="file3">billing_system_test_task/internal/repositories/reports/file_marshaller.go (100.0%)</option>
				
				<option value="file4">billing_system_test_task/internal/repositories/reports/pipes.go (100.0%)</option>
				
				<option value="file5">billing_system_test_task/internal/repositories/reports/query_params.go (100.0%)</option>
				
				<option value="file6">billing_system_test_task/internal/repositories/users.go (100.0%)</option>
				
				<option value="file7">billing_system_test_task/internal/repositories/wallet.go (100.0%)</option>
				
				<option value="file8">billing_system_test_task/internal/transport/http/api.go (100.0%)</option>
				
				<option value="file9">billing_system_test_task/internal/transport/http/errors.go (100.0%)</option>
				
				<option value="file10">billing_system_test_task/internal/transport/http/operation.go (100.0%)</option>
				
				<option value="file11">billing_system_test_task/internal/transport/http/user.go (100.0%)</option>
				
				<option value="file12">billing_system_test_task/internal/transport/http/wallet.go (100.0%)</option>
				
				<option value="file13">billing_system_test_task/internal/usecases/operation.go (100.0%)</option>
				
				<option value="file14">billing_system_test_task/internal/usecases/user.go (100.0%)</option>
				
				<option value="file15">billing_system_test_task/internal/usecases/wallet.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pipeline

import "sync"

// Pipe represents actions for element of pipeline
type Pipe interface {
        Call(in, out chan interface{})
}

// ExecutePipeline executes list of pipes
func ExecutePipeline(pipes ...Pipe) <span class="cov8" title="1">{
        in := make(chan interface{}, 1)
        wg := &amp;sync.WaitGroup{}
        wg.Add(len(pipes))
        for idx := range pipes </span><span class="cov8" title="1">{
                out := make(chan interface{}, 1)
                j := pipes[idx]
                go executeJob(in, out, j, wg)
                in = out
        }</span>
        <span class="cov8" title="1">wg.Wait()</span>
}

func executeJob(in, out chan interface{}, j Pipe, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()
        j.Call(in, out)
        close(out)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package repositories

import (
        "billing_system_test_task/internal/adapters/tx"
        "billing_system_test_task/internal/entities"
        "context"
        "fmt"

        "github.com/shopspring/decimal"
)

const (
        Retrieve   = "retrieve"
        Create     = "create wallet"
        Deposit    = "deposit"
        Withdrawal = "withdrawal"
)

type OperationsManager interface {
        WithTx(t tx.Tx) OperationsManager
        Create(ctx context.Context, operation string, walletFrom, walletTo int, amount decimal.Decimal) (int, error)
        List(ctx context.Context, params *ListParams) (chan *entities.WalletOperation, error)
}

type WalletOperationService struct {
        db tx.SQLQueryAdapter
}

type ListParams struct {
        Page    int
        PerPage int
        Date    string
}

func NewWalletOperationRepo(db tx.SQLQueryAdapter) *WalletOperationService <span class="cov8" title="1">{
        return &amp;WalletOperationService{
                db: db,
        }
}</span>

func (wor WalletOperationService) WithTx(t tx.Tx) OperationsManager <span class="cov8" title="1">{
        return NewWalletOperationRepo(t.(tx.SQLQueryAdapter))
}</span>

func (wor WalletOperationService) Create(ctx context.Context, operation string, walletFrom, walletTo int, amount decimal.Decimal) (int, error) <span class="cov8" title="1">{
        var (
                walletOperationID int
                walletFromValue   interface{}
        )

        if walletFrom == 0 </span><span class="cov8" title="1">{
                walletFromValue = nil
        }</span> else<span class="cov8" title="1"> {
                walletFromValue = walletFrom
        }</span>

        <span class="cov8" title="1">stmt, insertErr := wor.db.QueryContext(
                ctx,
                "insert into wallet_operations(operation, wallet_from, wallet_to, amount) values($1, $2, $3, $4) returning id",
                operation, walletFromValue, walletTo, amount,
        )

        if insertErr != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("error wallet operation creation: %s", insertErr)
        }</span>

        <span class="cov8" title="1">for stmt.Next() </span><span class="cov8" title="1">{
                scanErr := stmt.Scan(&amp;walletOperationID)
                if scanErr != nil </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("error wallet operation id retrieving: %s", scanErr)
                }</span>
        }

        <span class="cov8" title="1">return walletOperationID, nil</span>
}

func (wor WalletOperationService) List(ctx context.Context, params *ListParams) (chan *entities.WalletOperation, error) <span class="cov8" title="1">{
        opCh := make(chan *entities.WalletOperation, 1)
        defer close(opCh)

        query := "select id, operation, wallet_from, wallet_to, amount, created_at from wallet_operations"
        args := []interface{}{}
        if params != nil </span><span class="cov8" title="1">{
                page := params.Page
                if page == 1 </span><span class="cov8" title="1">{
                        page = 0
                }</span> else<span class="cov8" title="1"> {
                        page -= 1
                }</span>

                <span class="cov8" title="1">if params.Date != "" </span><span class="cov8" title="1">{
                        query += " where created_at = to_date($1, 'YYYY-MM-DD') "
                        args = append(args, params.Date)
                }</span>

                <span class="cov8" title="1">if params.PerPage != 0 </span><span class="cov8" title="1">{
                        var (
                                pageIdx    int
                                perPageIdx int
                                argsLen    = len(args)
                        )

                        if argsLen == 0 </span><span class="cov8" title="1">{
                                pageIdx = 1
                                perPageIdx = 2
                        }</span> else<span class="cov8" title="1"> {
                                pageIdx = argsLen + 1
                                perPageIdx = pageIdx + 1
                        }</span>
                        <span class="cov8" title="1">query += fmt.Sprintf(" offset $%d limit $%d", pageIdx, perPageIdx)
                        args = append(args, page*params.PerPage)
                        args = append(args, params.PerPage)</span>
                }
        }
        <span class="cov8" title="1">rows, queryRowErr := wor.db.QueryContext(
                ctx,
                query,
                args...,
        )
        if queryRowErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("[OPERATIONS_LIST]: %s", queryRowErr)
        }</span>

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                operation := entities.WalletOperation{}
                scanErr := rows.Scan(&amp;operation.ID, &amp;operation.Operation, &amp;operation.WalletFrom, &amp;operation.WalletTo, &amp;operation.Amount, &amp;operation.CreatedAt)
                if scanErr != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("[OPERATIONS_LIST_ROW]: %s", scanErr)
                }</span>
                <span class="cov8" title="1">opCh &lt;- &amp;operation</span>
        }

        <span class="cov8" title="1">return opCh, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package reports

import (
        "billing_system_test_task/internal/entities"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "sync"
)

type FileWithMetadata interface {
        Read(p []byte) (n int, err error)
        Stat() (os.FileInfo, error)
}

// FileHandlingManager represents interface for file handler
type FileHandlingManager interface {
        Create(format string) (*entities.FileParams, error)
        CreateMarshaller(file *os.File, format string, csvWriter CSVWriter) (FileMarshallingManager, error)
        GetFileMetadata(file FileWithMetadata) (*entities.Metadata, error)
}

// FileStorageManager represents interface for file storage
type FileStorageManager interface {
        Create(path string, flag int, perm os.FileMode) (*os.File, error)
}

// FileHandler implements FileHandlingManager interface
type FileHandler struct {
        fileStorage FileStorageManager
}

// FileStorage implements FileStorageManager interface
type FileStorage struct{}

func NewFileStorage() *FileStorage <span class="cov8" title="1">{
        return &amp;FileStorage{}
}</span>

// NewFileHandler returns new instance of FileHandler
func NewFileHandler(storage FileStorageManager) *FileHandler <span class="cov8" title="1">{
        return &amp;FileHandler{
                fileStorage: storage,
        }
}</span>

// Create creates new file
func (fs FileStorage) Create(path string, flag int, perm os.FileMode) (*os.File, error) <span class="cov8" title="1">{
        return os.OpenFile(path, flag, perm)
}</span>

// Create file with attributes
func (fh FileHandler) Create(format string) (*entities.FileParams, error) <span class="cov8" title="1">{
        var (
                path      string
                name      string
                csvWriter CSVWriter
        )

        name = "report." + format
        _, b, _, _ := runtime.Caller(0)
        basepath := filepath.Dir(b)
        path = filepath.Join(basepath, name)
        f, fileOpenErr := fh.fileStorage.Create(path, os.O_CREATE|os.O_RDWR|os.O_APPEND, 0666)
        if fileOpenErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error of creating file: %s", fileOpenErr)
        }</span>

        <span class="cov8" title="1">if format == "csv" </span><span class="cov8" title="1">{
                csvWriter = csv.NewWriter(f)
        }</span>

        <span class="cov8" title="1">return &amp;entities.FileParams{
                Name:      name,
                Path:      path,
                File:      f,
                CsvWriter: csvWriter,
        }, nil</span>
}

// CreateMarshaller returns file marshaller for particular format
func (fh FileHandler) CreateMarshaller(file *os.File, format string, csvWriter CSVWriter) (FileMarshallingManager, error) <span class="cov8" title="1">{
        var (
                mu          = &amp;sync.Mutex{}
                fileHandler FileMarshallingManager
        )

        if format == "csv" </span><span class="cov8" title="1">{
                headers := []string{
                        "id", "operation", "wallet_from", "wallet_to", "amount", "created_at",
                }
                writeErr := csvWriter.Write(headers)
                if writeErr != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error fo csv writing: %s", writeErr)
                }</span>
                <span class="cov8" title="1">fileHandler = &amp;CSVHandler{
                        csvWriter: csvWriter,
                        mu:        mu,
                }</span>
        } else<span class="cov8" title="1"> if format == "json" </span><span class="cov8" title="1">{
                fileHandler = &amp;JSONHandler{
                        file:     file,
                        mu:       mu,
                        marshall: json.Marshal,
                }
        }</span>
        <span class="cov8" title="1">return fileHandler, nil</span>
}

// GetFileMetadata retrieves file's metadata
func (fh FileHandler) GetFileMetadata(file FileWithMetadata) (*entities.Metadata, error) <span class="cov8" title="1">{
        header := make([]byte, 512)
        _, readErr := file.Read(header)
        if readErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error of file header's reading: %s", readErr)
        }</span>
        <span class="cov8" title="1">stat, statErr := file.Stat()
        if statErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error of file stats's receiving: %s", statErr)
        }</span>
        <span class="cov8" title="1">size := strconv.FormatInt(stat.Size(), 10)
        contentType := http.DetectContentType(header)
        return &amp;entities.Metadata{
                Size:        size,
                ContentType: contentType,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package reports

import (
        "billing_system_test_task/internal/entities"
        "fmt"
        "io"
        "strconv"
        "sync"
)

// FileMarshallingManager defines contracts for file marshalling
type FileMarshallingManager interface {
        MarshallOperation(operation *entities.WalletOperation) (*MarshalledResult, error)
        WriteToFile(mr *MarshalledResult) error
}

// FileMarshallingManager represents methods for csv writing
type CSVWriter interface {
        Write(record []string) error
        Flush()
}

// JSONHandler implements FileMarshallingManager interface for json format
type JSONHandler struct {
        file     io.Writer
        mu       *sync.Mutex
        marshall func(v interface{}) ([]byte, error)
}

func NewJSONHandler(file io.Writer, mu *sync.Mutex, marshall func(v interface{}) ([]byte, error)) *JSONHandler <span class="cov8" title="1">{
        return &amp;JSONHandler{
                file:     file,
                mu:       mu,
                marshall: marshall,
        }
}</span>

// MarshallOperation marshal entities.WalletOperation instance to json
func (jh *JSONHandler) MarshallOperation(operation *entities.WalletOperation) (*MarshalledResult, error) <span class="cov8" title="1">{
        jsonBytes, jsonMarshallErr := jh.marshall(operation)
        if jsonMarshallErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error of json marshalling: %s", jsonMarshallErr)
        }</span>
        <span class="cov8" title="1">newLine := []byte("\n")
        data := append(jsonBytes, newLine...)
        return &amp;MarshalledResult{
                id:   operation.ID,
                data: data,
        }, nil</span>
}

// WriteToFile writes given marshall result to json file
func (jh *JSONHandler) WriteToFile(mr *MarshalledResult) error <span class="cov8" title="1">{
        var syncErr error
        bytesData := mr.data.([]byte)
        jh.mu.Lock()
        _, writeErr := jh.file.Write(bytesData)
        if writeErr != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("write file error: %s", syncErr)
        }</span>
        <span class="cov8" title="1">jh.mu.Unlock()
        return nil</span>
}

// JSONHandler implements FileMarshallingManager interface for csv format
type CSVHandler struct {
        csvWriter CSVWriter
        mu        *sync.Mutex
}

func NewCSVHandler(csvWriter CSVWriter, mu *sync.Mutex) *CSVHandler <span class="cov8" title="1">{
        return &amp;CSVHandler{
                csvWriter: csvWriter,
                mu:        mu,
        }
}</span>

// MarshallOperation marshal entities.WalletOperation instance to csv
func (ch *CSVHandler) MarshallOperation(operation *entities.WalletOperation) (*MarshalledResult, error) <span class="cov8" title="1">{
        idStr := strconv.Itoa(operation.ID)
        walletFromStr := strconv.Itoa(int(operation.WalletFrom.Int32))
        walletToStr := strconv.Itoa(int(operation.WalletTo))
        amountStr := operation.Amount.String()
        createdAtStr := operation.CreatedAt.String()
        row := []string{
                idStr,
                operation.Operation,
                walletFromStr,
                walletToStr,
                amountStr,
                createdAtStr,
        }
        return &amp;MarshalledResult{
                id:   operation.ID,
                data: row,
        }, nil
}</span>

// WriteToFile writes given marshall result to csv file
func (ch *CSVHandler) WriteToFile(mr *MarshalledResult) error <span class="cov8" title="1">{
        row := mr.data.([]string)
        ch.mu.Lock()
        csvWriteErr := ch.csvWriter.Write(row)
        if csvWriteErr != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error fo csv writing: %s", csvWriteErr)
        }</span>
        <span class="cov8" title="1">ch.mu.Unlock()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package reports

import (
        "billing_system_test_task/internal/entities"
        "billing_system_test_task/internal/pipeline"
        "billing_system_test_task/internal/repositories"
        "context"
        "fmt"
        "sync"
)

// PipelineManager defines operations for processing entities.WalletOperation
type PipelineManager interface {
        Process(ctx context.Context, or repositories.OperationsManager, listParams *repositories.ListParams, marshaller FileMarshallingManager) error
}

// OperationsProcessesManager represents PipelineManager interface
type OperationsProcessesManager struct{}

func NewOperationsProcessesManager() *OperationsProcessesManager <span class="cov8" title="1">{
        return &amp;OperationsProcessesManager{}
}</span>

// Process runs pipeline through all the stages
func (op OperationsProcessesManager) Process(ctx context.Context, or repositories.OperationsManager, listParams *repositories.ListParams, marshaller FileMarshallingManager) error <span class="cov8" title="1">{
        var (
                wg     = &amp;sync.WaitGroup{}
                errors = make(chan error, 1)
        )
        readPipe := ReadPipe{
                or:     or,
                wg:     wg,
                params: listParams,
                ctx:    ctx,
                errors: errors,
        }
        marshallPipe := MarshallPipe{
                wg:     wg,
                fm:     marshaller,
                errors: errors,
        }
        writePipe := WritePipe{
                wg:     wg,
                fm:     marshaller,
                errors: errors,
        }
        pipes := []pipeline.Pipe{
                readPipe,
                marshallPipe,
                writePipe,
        }

        wg.Add(len(pipes))
        pipeline.ExecutePipeline(pipes...)
        wg.Wait()

        select </span>{
        case err := &lt;-errors:<span class="cov8" title="1">
                return fmt.Errorf("operations read failed: %s", err)</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

// ReadPipe represents reading part of pipeline
type ReadPipe struct {
        or     repositories.OperationsManager
        errors chan error
        wg     *sync.WaitGroup
        params *repositories.ListParams
        ctx    context.Context
}

// Call reads rows from database and pass them further throught the pipeline
func (rp ReadPipe) Call(in, out chan interface{}) <span class="cov8" title="1">{
        defer rp.wg.Done()
        var counter int

        rowsCh, rowsErr := rp.or.List(rp.ctx, rp.params)
        if rowsErr != nil </span><span class="cov8" title="1">{
                rp.errors &lt;- fmt.Errorf("error of row retrieving: %s", rowsErr)
                out &lt;- nil
                return
        }</span>
        <span class="cov8" title="1">for operation := range rowsCh </span><span class="cov8" title="1">{
                counter++
                out &lt;- operation
        }</span>
        <span class="cov8" title="1">if counter == 0 </span><span class="cov8" title="1">{
                out &lt;- nil
        }</span>
}

// MarshallPipe represents marshalling part of pipeline (to csv or json)
type MarshallPipe struct {
        wg     *sync.WaitGroup
        fm     FileMarshallingManager
        errors chan error
}

// Call marshall received rows to csv or json
func (mp MarshallPipe) Call(in, out chan interface{}) <span class="cov8" title="1">{
        defer mp.wg.Done()

        for chunk := range in </span><span class="cov8" title="1">{
                if chunk == nil </span><span class="cov8" title="1">{
                        out &lt;- nil
                        return
                }</span>
                <span class="cov8" title="1">operation := chunk.(*entities.WalletOperation)
                mr, mrErr := mp.fm.MarshallOperation(operation)
                if mrErr != nil </span><span class="cov8" title="1">{
                        out &lt;- nil
                        err := fmt.Errorf("[ERROR] Marshalling error: %s", mrErr)
                        mp.errors &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">out &lt;- mr</span>
        }
}

// WritePipe represents writing to file part of pipeline
type WritePipe struct {
        wg     *sync.WaitGroup
        fm     FileMarshallingManager
        errors chan error
}

// Call write receive marshalled items to file
func (wp WritePipe) Call(in, out chan interface{}) <span class="cov8" title="1">{
        defer wp.wg.Done()

        for chunk := range in </span><span class="cov8" title="1">{
                if chunk != nil </span><span class="cov8" title="1">{
                        mr := chunk.(*MarshalledResult)
                        writeErr := wp.fm.WriteToFile(mr)
                        if writeErr != nil </span><span class="cov8" title="1">{
                                wp.errors &lt;- fmt.Errorf("[ERROR] Write to file error: %s", writeErr)
                                return
                        }</span>
                }
        }
}

// MarshalledResult represents result of marshalling operation
type MarshalledResult struct {
        id   int
        data interface{}
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package reports

import (
        "billing_system_test_task/internal/repositories"
        "fmt"
        "net/url"
        "strconv"
)

// QueryReaderManager represents actions for query parameters reading
type QueryReaderManager interface {
        Parse(query url.Values) (*QueryParams, error)
}

// QueryParams represents parameters for
type QueryParams struct {
        Format     string
        ListParams *repositories.ListParams
}

// QueryParams implements QueryReaderManager interface
type QueryParamsReader struct{}

func NewQueryParamsReader() *QueryParamsReader <span class="cov8" title="1">{
        return &amp;QueryParamsReader{}
}</span>

// Parse returns given URL query parameters
func (qpr QueryParamsReader) Parse(query url.Values) (*QueryParams, error) <span class="cov8" title="1">{
        var (
                format string
                params = &amp;repositories.ListParams{}
        )
        format = query.Get("format")
        pageStr := query.Get("page")
        perPageStr := query.Get("per_page")
        date := query.Get("date")

        if format == "" </span><span class="cov8" title="1">{
                format = "json"
        }</span>

        <span class="cov8" title="1">if pageStr != "" &amp;&amp; perPageStr != "" </span><span class="cov8" title="1">{
                page, pageConvError := strconv.Atoi(pageStr)
                if pageConvError != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error of 'page' attribute converting: %s", pageConvError)
                }</span>

                <span class="cov8" title="1">perPage, perPageConvError := strconv.Atoi(perPageStr)
                if perPageConvError != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error of 'per_page' attribute converting: %s", pageConvError)
                }</span>

                <span class="cov8" title="1">params.Page = page
                params.PerPage = perPage</span>
        }
        <span class="cov8" title="1">if date != "" </span><span class="cov8" title="1">{
                params.Date = date
        }</span>

        <span class="cov8" title="1">return &amp;QueryParams{
                Format:     format,
                ListParams: params,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repositories

import (
        "billing_system_test_task/internal/adapters/tx"
        "billing_system_test_task/internal/entities"
        "context"
        "fmt"
)

const (
        CreateUser = iota + 1
)

// UsersManager represents communication with users
type UsersManager interface {
        WithTx(t tx.Tx) UsersManager
        GetByID(ctx context.Context, userID int) (*entities.User, error)
        GetByWalletID(ctx context.Context, walletID int) (*entities.User, error)
        Create(ctx context.Context, email string) (int64, error)
}

// UsersService implements SQLRepository
type UsersService struct {
        db tx.SQLQueryAdapter
}

// NewUsersService returns instance of UserService
func NewUsersService(db tx.SQLQueryAdapter) *UsersService <span class="cov8" title="1">{
        return &amp;UsersService{
                db: db,
        }
}</span>

func (us *UsersService) WithTx(t tx.Tx) UsersManager <span class="cov8" title="1">{
        return NewUsersService(t.(tx.SQLQueryAdapter))
}</span>

// GetByID receives user information by id
func (ds UsersService) GetByID(ctx context.Context, userID int) (*entities.User, error) <span class="cov8" title="1">{
        user := entities.User{}
        query := `
                select u.id, u.email, w.id, w.user_id, w.balance, w.currency 
                from users as u 
                join wallets as w 
                on u.id = w.user_id 
                where u.id = $1
        `

        userRow, getUserErr := ds.db.QueryContext(ctx, query, userID)
        if getUserErr != nil </span><span class="cov8" title="1">{
                return nil, getUserErr
        }</span>
        <span class="cov8" title="1">for userRow.Next() </span><span class="cov8" title="1">{
                wallet := entities.Wallet{}
                scanErr := userRow.Scan(
                        &amp;user.ID,
                        &amp;user.Email,
                        &amp;wallet.ID,
                        &amp;wallet.UserID,
                        &amp;wallet.Balance,
                        &amp;wallet.Currency,
                )
                if scanErr != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("GetByID: Error of reading the result: %s", scanErr)
                }</span>
                <span class="cov8" title="1">user.Wallet = &amp;wallet</span>
        }

        <span class="cov8" title="1">return &amp;user, nil</span>
}

// GetByWalletID receives user information by wallet id
func (ds UsersService) GetByWalletID(ctx context.Context, walletID int) (*entities.User, error) <span class="cov8" title="1">{
        user := entities.User{}
        query := `
                select u.id, u.email, w.id, w.user_id, w.balance, w.currency 
                from users as u
                join wallets as w
                on u.id = w.user_id
                where w.id = $1
        `
        userRow, userGetErr := ds.db.QueryContext(ctx, query, walletID)
        if userGetErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("GetByWalletID: error of receiving user: %s", userGetErr)
        }</span>

        <span class="cov8" title="1">for userRow.Next() </span><span class="cov8" title="1">{
                wallet := entities.Wallet{}
                scanErr := userRow.Scan(
                        &amp;user.ID,
                        &amp;user.Email,
                        &amp;wallet.ID,
                        &amp;wallet.UserID,
                        &amp;wallet.Balance,
                        &amp;wallet.Currency,
                )
                if scanErr != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("GetByWalletID: Error of reading the result: %s", scanErr)
                }</span>
                <span class="cov8" title="1">user.Wallet = &amp;wallet</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}

// Create creates new user
func (us UsersService) Create(ctx context.Context, email string) (int64, error) <span class="cov8" title="1">{
        var userID int
        // Creates new user
        statement, insertErr := us.db.QueryContext(ctx, "insert into users(\"email\") values($1) returning id", email)

        if insertErr != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("error user creation: %s", insertErr)
        }</span>

        <span class="cov8" title="1">for statement.Next() </span><span class="cov8" title="1">{
                userIDErr := statement.Scan(&amp;userID)
                if userIDErr != nil </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("error user retrieving id: %s", userIDErr)
                }</span>
        }

        <span class="cov8" title="1">return int64(userID), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repositories

import (
        "billing_system_test_task/internal/adapters/tx"
        "billing_system_test_task/internal/entities"
        "context"
        "fmt"

        "github.com/shopspring/decimal"
)

const (
        CreateWallet = iota + 1
        EnrollWallet
        TransferFunds
)

// WalletsManager represents communication with wallets
type WalletsManager interface {
        WithTx(t tx.Tx) WalletsManager
        Create(ctx context.Context, userID int64) (int64, error)
        Enroll(ctx context.Context, walletID int, amount decimal.Decimal) (int, error)
        GetByUserId(ctx context.Context, userID int) (*entities.Wallet, error)
        GetByID(ctx context.Context, walletID int) (*entities.Wallet, error)
        Transfer(ctx context.Context, walletFrom, walletTo int, amount decimal.Decimal) (int, error)
}

// WalletService shows structure for service of wallets
type WalletService struct {
        db tx.SQLQueryAdapter
}

// NewWalletService returns instance of WalletService
func NewWalletService(db tx.SQLQueryAdapter) *WalletService <span class="cov8" title="1">{
        return &amp;WalletService{
                db: db,
        }
}</span>

func (ws WalletService) WithTx(t tx.Tx) WalletsManager <span class="cov8" title="1">{
        return NewWalletService(t.(tx.SQLQueryAdapter))
}</span>

// Create creates new wallet for user
func (ws WalletService) Create(ctx context.Context, userID int64) (int64, error) <span class="cov8" title="1">{
        var (
                walletID int64
        )

        stmt, insertErr := ws.db.QueryContext(
                ctx,
                "insert into wallets(user_id) values($1) returning id",
                userID,
        )

        if insertErr != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("error wallet creation: %s", insertErr)
        }</span>

        <span class="cov8" title="1">for stmt.Next() </span><span class="cov8" title="1">{
                scanErr := stmt.Scan(&amp;walletID)
                if scanErr != nil </span><span class="cov8" title="1">{
                        return 0, fmt.Errorf("error wallet id retrieving: %s", scanErr)
                }</span>
        }

        <span class="cov8" title="1">return walletID, nil</span>
}

// Enroll updates wallet's balance
func (ws WalletService) Enroll(ctx context.Context, walletID int, amount decimal.Decimal) (int, error) <span class="cov8" title="1">{
        // Check if amount is less or equal to 0
        if amount.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("amount should be greater than 0")
        }</span>

        // Update wallet 'balance' column
        <span class="cov8" title="1">_, updateErr := ws.db.ExecContext(ctx, "update wallets set balance=balance+$1 where id=$2 returning balance", amount, walletID)
        if updateErr != nil </span><span class="cov8" title="1">{
                // _ = tx.Rollback()
                // _, _ = conn.ExecContext(ctx, `select pg_advisory_unlock($1)`, EnrollWallet)
                return 0, fmt.Errorf("error wallet enrollment: %s", updateErr)
        }</span>

        <span class="cov8" title="1">return walletID, nil</span>
}

// GetByID retrieves wallet by its ID
func (ws WalletService) GetByID(ctx context.Context, walletID int) (*entities.Wallet, error) <span class="cov8" title="1">{
        wallet := entities.Wallet{}
        getWalletErr := ws.db.
                QueryRowContext(ctx, "select id, user_id, balance, currency from wallets where id=$1", walletID).
                Scan(&amp;wallet.ID, &amp;wallet.UserID, &amp;wallet.Balance, &amp;wallet.Currency)
        if getWalletErr != nil </span><span class="cov8" title="1">{
                return nil, getWalletErr
        }</span>
        <span class="cov8" title="1">return &amp;wallet, nil</span>
}

// GetByUserId retrieves wallet by user ID
func (ws WalletService) GetByUserId(ctx context.Context, userID int) (*entities.Wallet, error) <span class="cov8" title="1">{
        wallet := entities.Wallet{}
        getWalletErr := ws.db.
                QueryRowContext(ctx, "select id, user_id, balance, currency from wallets where user_id=$1", userID).
                Scan(&amp;wallet.ID, &amp;wallet.UserID, &amp;wallet.Balance, &amp;wallet.Currency)
        if getWalletErr != nil </span><span class="cov8" title="1">{
                return nil, getWalletErr
        }</span>
        <span class="cov8" title="1">return &amp;wallet, nil</span>
}

// Transfer moves financial resources from one wallet to another
func (ws WalletService) Transfer(ctx context.Context, walletFrom, walletTo int, amount decimal.Decimal) (int, error) <span class="cov8" title="1">{
        // Update source wallet 'balance' column
        _, updateSourceErr := ws.db.ExecContext(ctx, "update wallets set balance=balance-$1 where id=$2", amount, walletFrom)
        if updateSourceErr != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("error source wallet debit: %s", updateSourceErr)
        }</span>

        // Update target wallet 'balance' column
        <span class="cov8" title="1">_, updateTargetErr := ws.db.ExecContext(ctx, "update wallets set balance=balance+$1 where id=$2", amount, walletTo)
        if updateTargetErr != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("error target wallet transfer: %s", updateTargetErr)
        }</span>

        <span class="cov8" title="1">return walletFrom, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package http

import (
        "net/http"

        _ "billing_system_test_task/docs" // docs is generated by Swag CLI, you have to import it.

        "github.com/gorilla/mux"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        httpSwagger "github.com/swaggo/http-swagger"
)

// @title Billing System API
// @version 1.0
// @description Simple billing system
// @termsOfService http://swagger.io/terms/
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8000
// @BasePath /
func NewRouter(usersHandler *UsersHandler, walletsHandler *WalletsHandler, operationsHandler *OperationsHandler) http.Handler <span class="cov8" title="1">{
        r := mux.NewRouter()

        api := r.PathPrefix("/api").Subrouter()
        api.HandleFunc("/users/", usersHandler.Create).Methods("POST").Name("CREATE_USER")
        api.HandleFunc("/users/{id}/enroll/", usersHandler.Enroll).Methods("POST").Name("ENROLL_USER_WALLET")
        api.HandleFunc("/wallets/transfer/", walletsHandler.Transfer).Methods("POST").Name("Transfer funds")
        api.HandleFunc("/operations/", operationsHandler.List).Methods("GET").Name("OPERATIONS_LIST")
        r.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler)
        r.Handle("/metrics", promhttp.Handler())
        return r
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package http

import (
        "encoding/json"
        "net/http"
)

type FormErrorSerializer struct {
        Messages map[string][]string `json:"messages"`
}

type ErrorMsg struct {
        Message string `json:"message"`
}

func JsonResponseError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(ErrorMsg{Message: message})
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package http

import (
        "billing_system_test_task/internal/usecases"
        "net/http"
        "os"
)

// OperationsHandler represents handler structure for the operatons
type OperationsHandler struct {
        woUseCase usecases.WalletOperationUsecase
}

// NewOperationsHandler returns controller instance
func NewOperationsHandler(woUseCase usecases.WalletOperationUsecase) *OperationsHandler <span class="cov8" title="1">{
        return &amp;OperationsHandler{
                woUseCase: woUseCase,
        }
}</span>

// Create godoc
// @Summary Wallet operations
// @Description Get wallet operations logs
// @Tags operations
// @Accept  json
// @Produce application/octet-stream
// @Param format query string false "Report format"
// @Param page query int false "Page number"
// @Param per_page query int false "Number of items per page"
// @Param date query int false "Number of items per page"
// @Router /api/operations/ [get]
// @Header 200 {string} Content-Type "application/octet-stream"
// @Header 200 {string} Expires "0"
func (oh *OperationsHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        v := r.URL.Query()
        fileMetadata, grErr := oh.woUseCase.GenerateReport(ctx, v)
        if grErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, grErr.GetStatus(), grErr.GetError().Error())
                return
        }</span>

        <span class="cov8" title="1">defer func(path string, f *os.File) </span><span class="cov8" title="1">{
                f.Close()
                os.Remove(path)
        }</span>(fileMetadata.Path, fileMetadata.File)

        <span class="cov8" title="1">w.Header().Set("Content-Disposition", "attachment; filename="+fileMetadata.File.Name())
        w.Header().Set("Content-Type", fileMetadata.ContentType)
        w.Header().Set("Content-Length", fileMetadata.Size)
        w.WriteHeader(http.StatusOK)

        http.ServeFile(w, r, fileMetadata.Path)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package http

import (
        "billing_system_test_task/internal/entities"
        "billing_system_test_task/internal/repositories"
        "billing_system_test_task/internal/transport/http/forms"
        "billing_system_test_task/internal/transport/http/serializers"
        "billing_system_test_task/internal/usecases"
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
)

// UsersHandler stores attributes for handler
type UsersHandler struct {
        UsersRepo   repositories.UsersManager
        WalletsRepo repositories.WalletsManager
        userUseCase usecases.UserUseCase
}

func NewUserHandler(userUseCase usecases.UserUseCase) *UsersHandler <span class="cov8" title="1">{
        return &amp;UsersHandler{
                userUseCase: userUseCase,
        }
}</span>

// Create godoc
// @Summary Create new user
// @Description Create new user and wallet
// @Tags users
// @Accept  json
// @Produce  json
// @Param user body forms.UserForm true "User attributes"
// @Success 201 {object} serializers.UserSerializer "Create user response"
// @Failure 400 {object} FormErrorSerializer "User form validation error"
// @Failure default {object} ErrorMsg
// @Router /api/users/ [post]
func (uh *UsersHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var (
                userForm forms.UserForm
                ctx      = r.Context()
        )

        decoder := json.NewDecoder(r.Body)
        decodeErr := decoder.Decode(&amp;userForm)
        if decodeErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, http.StatusBadRequest, fmt.Sprintf("Error json form decoding: %s", decodeErr))
                return
        }</span>

        // Validate body parameters
        <span class="cov8" title="1">formError := userForm.Submit()
        if formError != nil </span><span class="cov8" title="1">{
                log.Println(fmt.Sprintf("[ERROR] Create user: %s", formError))
                w.WriteHeader(http.StatusBadRequest)
                serializer := FormErrorSerializer{Messages: *formError}
                _ = json.NewEncoder(w).Encode(serializer)
                return
        }</span>

        <span class="cov8" title="1">user, createUserErr := uh.userUseCase.Create(ctx, userForm.Email)

        if createUserErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, createUserErr.GetStatus(), createUserErr.GetError().Error())
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusCreated)
        _ = json.NewEncoder(w).Encode(serializers.UserSerializer{
                ID:       user.ID,
                Email:    user.Email,
                Balance:  user.Wallet.Balance,
                Currency: user.Wallet.Currency,
        })</span>
}

// @Summary Enroll wallet
// @Description Enroll particular users wallet
// @Tags users
// @Accept  json
// @Produce  json
// @Param id path int true "User ID"
// @Param enroll body forms.EnrollForm true "Enrollment attributes"
// @Success 200 {object} serializers.UserSerializer "Retrieving user information with updated balance"
// @Failure 400 {object} FormErrorSerializer "Enroll form validation error"
// @Failure default {object} ErrorMsg
// @Router /api/users/{id}/enroll/ [post]
func (uh *UsersHandler) Enroll(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var (
                enrollForm forms.EnrollForm
                ctx        = context.Background()
                user       *entities.User
        )

        vars := mux.Vars(r)
        userIDVar, userIDExists := vars["id"]
        if !userIDExists </span><span class="cov8" title="1">{
                JsonResponseError(w, http.StatusInternalServerError, "user's id attribute does not exists")
                return
        }</span>

        <span class="cov8" title="1">userID, errIntConv := strconv.Atoi(userIDVar)
        if errIntConv != nil </span><span class="cov8" title="1">{
                errorMsg := fmt.Sprintf("Error formatting user id to int: %s", errIntConv)
                JsonResponseError(w, http.StatusBadRequest, errorMsg)
                return
        }</span>

        <span class="cov8" title="1">decoder := json.NewDecoder(r.Body)
        decodeErr := decoder.Decode(&amp;enrollForm)
        if decodeErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, http.StatusBadRequest, fmt.Sprintf("Error json form decoding: %s", decodeErr))
                return
        }</span>

        // Validate body parameters
        <span class="cov8" title="1">formError := enrollForm.Submit()
        if formError != nil </span><span class="cov8" title="1">{
                log.Println(fmt.Sprintf("[ERROR] Enroll user wallet: %s", formError))
                w.WriteHeader(http.StatusBadRequest)
                _ = json.NewEncoder(w).Encode(FormErrorSerializer{Messages: *formError})
                return
        }</span>

        <span class="cov8" title="1">user, walletEnrollErr := uh.userUseCase.Enroll(ctx, userID, enrollForm.Amount)
        if walletEnrollErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, walletEnrollErr.GetStatus(), fmt.Sprintf("Error of wallet enroll: %s", walletEnrollErr.GetError()))
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(serializers.UserSerializer{
                ID:       user.ID,
                Email:    user.Email,
                Balance:  user.Wallet.Balance,
                Currency: user.Wallet.Currency,
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "billing_system_test_task/internal/repositories"
        "billing_system_test_task/internal/transport/http/forms"
        "billing_system_test_task/internal/transport/http/serializers"
        "billing_system_test_task/internal/usecases"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
)

type WalletsHandler struct {
        WalletRepo    repositories.WalletsManager
        walletUseCase usecases.WalletUseCase
}

func NewWalletsHandler(walletUseCase usecases.WalletUseCase) *WalletsHandler <span class="cov8" title="1">{
        return &amp;WalletsHandler{
                walletUseCase: walletUseCase,
        }
}</span>

// Create godoc
// @Summary Transfer funds
// @Description Transfer funds between two users
// @Tags wallets
// @Accept  json
// @Produce  json
// @Param user body forms.WalletForm true "Transfer parameters"
// @Success 200 {object} serializers.WalletSerializer "Wallet from id"
// @Failure 400 {object} FormErrorSerializer "Wallet transfer validation error"
// @Failure default {object} ErrorMsg
// @Router /api/wallets/transfer/ [post]
func (wh *WalletsHandler) Transfer(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var (
                walletForm forms.WalletForm
                ctx        = r.Context()
        )
        decoder := json.NewDecoder(r.Body)
        decodeErr := decoder.Decode(&amp;walletForm)
        if decodeErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, http.StatusBadRequest, fmt.Sprintf("Error json form decoding: %s", decodeErr))
                return
        }</span>

        // Validate body parameters
        <span class="cov8" title="1">formError := walletForm.Submit()
        if formError != nil </span><span class="cov8" title="1">{
                log.Println(fmt.Sprintf("[ERROR] Transfer error - %s", *formError))
                w.WriteHeader(http.StatusBadRequest)
                _ = json.NewEncoder(w).Encode(FormErrorSerializer{Messages: *formError})
                return
        }</span>

        <span class="cov8" title="1">walletFrom, walletTransferErr := wh.walletUseCase.Transfer(ctx, walletForm.WalletFrom, walletForm.WalletTo, walletForm.Amount)
        if walletTransferErr != nil </span><span class="cov8" title="1">{
                JsonResponseError(w, walletTransferErr.GetStatus(), fmt.Sprintf("Error of funds transfer: %s", walletTransferErr.GetError()))
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        _ = json.NewEncoder(w).Encode(serializers.WalletSerializer{
                WalletFrom: walletFrom,
        })</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package usecases

import (
        "billing_system_test_task/internal/adapters"
        "billing_system_test_task/internal/entities"
        "billing_system_test_task/internal/repositories"
        "billing_system_test_task/internal/repositories/reports"
        "context"
        "net/url"
)

type WalletOperationUsecase interface {
        GenerateReport(ctx context.Context, queryParams url.Values) (*entities.FileMetadata, adapters.Error)
}

type WalletOperationInteractor struct {
        walletOperationRepo     repositories.OperationsManager
        queryParameters         reports.QueryReaderManager
        fileHandler             reports.FileHandlingManager
        operationProcessManager reports.PipelineManager
        errorsFactory           adapters.ErrorsFactory
}

func NewWalletOperationInteractor(walletOperationRepo repositories.OperationsManager, queryParameters reports.QueryReaderManager, fileHandler reports.FileHandlingManager, operationProcessManager reports.PipelineManager, errorsFactory adapters.ErrorsFactory) *WalletOperationInteractor <span class="cov8" title="1">{
        return &amp;WalletOperationInteractor{
                walletOperationRepo:     walletOperationRepo,
                queryParameters:         queryParameters,
                fileHandler:             fileHandler,
                operationProcessManager: operationProcessManager,
                errorsFactory:           errorsFactory,
        }
}</span>

func (wor *WalletOperationInteractor) GenerateReport(ctx context.Context, queryParams url.Values) (*entities.FileMetadata, adapters.Error) <span class="cov8" title="1">{
        // Parse query parameters
        qp, qpErr := wor.queryParameters.Parse(queryParams)
        if qpErr != nil </span><span class="cov8" title="1">{
                return nil, wor.errorsFactory.DefaultError(qpErr)
        }</span>

        // Create new file for report
        <span class="cov8" title="1">fileParams, fpErr := wor.fileHandler.Create(qp.Format)
        if fpErr != nil </span><span class="cov8" title="1">{
                return nil, wor.errorsFactory.DefaultError(fpErr)
        }</span>

        // Creates file marshaller
        <span class="cov8" title="1">fileHandler, fhErr := wor.fileHandler.CreateMarshaller(
                fileParams.File,
                qp.Format,
                fileParams.CsvWriter,
        )
        if fhErr != nil </span><span class="cov8" title="1">{
                return nil, wor.errorsFactory.DefaultError(fhErr)
        }</span>

        // Process receiving, marshalling and writing to file wallet operations
        <span class="cov8" title="1">processErr := wor.operationProcessManager.Process(ctx, wor.walletOperationRepo, qp.ListParams, fileHandler)
        if processErr != nil </span><span class="cov8" title="1">{
                return nil, wor.errorsFactory.DefaultError(processErr)
        }</span>

        // Get file metadata
        <span class="cov8" title="1">metadata, metadataErr := wor.fileHandler.GetFileMetadata(fileParams.File)
        if metadataErr != nil </span><span class="cov8" title="1">{
                return nil, wor.errorsFactory.DefaultError(metadataErr)
        }</span>
        <span class="cov8" title="1">return &amp;entities.FileMetadata{
                File:        fileParams.File,
                Path:        fileParams.Path,
                Size:        metadata.Size,
                ContentType: metadata.ContentType,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package usecases

import (
        "billing_system_test_task/internal/adapters"
        trx "billing_system_test_task/internal/adapters/tx"
        "billing_system_test_task/internal/entities"
        "billing_system_test_task/internal/repositories"
        "context"

        "github.com/shopspring/decimal"
)

// UserUseCase represents contracts for user's use cases
type UserUseCase interface {
        Create(ctx context.Context, email string) (*entities.User, adapters.Error)
        Enroll(ctx context.Context, userID int, amount decimal.Decimal) (*entities.User, adapters.Error)
}

type UserInteractor struct {
        errorsFactory     adapters.ErrorsFactory
        userRepo          repositories.UsersManager
        walletsRepo       repositories.WalletsManager
        operationsManager repositories.OperationsManager
        txManager         trx.TxBeginner
}

func NewUserInteractor(userRepo repositories.UsersManager, walletsRepo repositories.WalletsManager, operationsManager repositories.OperationsManager, txManager trx.TxBeginner, errorsFactory adapters.ErrorsFactory) *UserInteractor <span class="cov8" title="1">{
        return &amp;UserInteractor{
                userRepo:          userRepo,
                walletsRepo:       walletsRepo,
                txManager:         txManager,
                operationsManager: operationsManager,
                errorsFactory:     errorsFactory,
        }
}</span>

// Create creates new user, its wallet and operation for that event
func (ui UserInteractor) Create(ctx context.Context, email string) (*entities.User, adapters.Error) <span class="cov8" title="1">{
        var (
                tx    trx.Tx
                txErr error
        )
        defer trx.RollbackTx(tx, txErr)

        tx, txErr = ui.txManager.BeginTrx(ctx, nil)
        if txErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(txErr)
        }</span>

        <span class="cov8" title="1">txUserRepo := ui.userRepo.WithTx(tx)
        userID, userErr := txUserRepo.Create(ctx, email)
        if userErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(userErr)
        }</span>

        <span class="cov8" title="1">walletID, walletErr := ui.walletsRepo.WithTx(tx).Create(ctx, userID)
        if walletErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(walletErr)
        }</span>

        <span class="cov8" title="1">_, walletOperationErr := ui.operationsManager.WithTx(tx).Create(ctx, repositories.Create, 0, int(walletID), decimal.NewFromInt(0))
        if walletOperationErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(walletOperationErr)
        }</span>

        <span class="cov8" title="1">user, getUserErr := txUserRepo.GetByWalletID(ctx, int(walletID))
        if getUserErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.NotFound(getUserErr)
        }</span>

        <span class="cov8" title="1">if commitErr := tx.Commit(); commitErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(commitErr)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (ui UserInteractor) Enroll(ctx context.Context, userID int, amount decimal.Decimal) (*entities.User, adapters.Error) <span class="cov8" title="1">{
        var (
                tx    trx.Tx
                txErr error
        )
        defer trx.RollbackTx(tx, txErr)

        tx, txErr = ui.txManager.BeginTrx(ctx, nil)
        if txErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(txErr)
        }</span>

        <span class="cov8" title="1">txUserRepo := ui.userRepo.WithTx(tx)

        user, getUserErr := txUserRepo.GetByID(ctx, userID)
        if getUserErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.NotFound(getUserErr)
        }</span>

        <span class="cov8" title="1">walletID, enrollWalletErr := ui.walletsRepo.WithTx(tx).Enroll(ctx, user.Wallet.ID, amount)
        if enrollWalletErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(enrollWalletErr)
        }</span>

        <span class="cov8" title="1">enrolledUser, enrolledUserErr := txUserRepo.GetByWalletID(ctx, walletID)
        if enrolledUserErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.NotFound(enrolledUserErr)
        }</span>

        <span class="cov8" title="1">if commitErr := tx.Commit(); commitErr != nil </span><span class="cov8" title="1">{
                return nil, ui.errorsFactory.DefaultError(commitErr)
        }</span>
        <span class="cov8" title="1">return enrolledUser, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package usecases

import (
        "billing_system_test_task/internal/adapters"
        trx "billing_system_test_task/internal/adapters/tx"
        "billing_system_test_task/internal/repositories"
        "context"
        "fmt"

        "github.com/shopspring/decimal"
)

// WalletUseCase represents contracts for wallet's use cases
type WalletUseCase interface {
        Transfer(ctx context.Context, walletFrom, walletTo int, amount decimal.Decimal) (int, adapters.Error)
}

type WalletInteractor struct {
        walletRepo        repositories.WalletsManager
        errFactory        adapters.ErrorsFactory
        txManager         trx.TxBeginner
        operationsManager repositories.OperationsManager
}

func NewWalletInteractor(walletRepo repositories.WalletsManager, operationsManager repositories.OperationsManager, errFactory adapters.ErrorsFactory, txManager trx.TxBeginner) *WalletInteractor <span class="cov8" title="1">{
        return &amp;WalletInteractor{
                walletRepo:        walletRepo,
                errFactory:        errFactory,
                txManager:         txManager,
                operationsManager: operationsManager,
        }
}</span>

func (wi *WalletInteractor) Transfer(ctx context.Context, walletFrom, walletTo int, amount decimal.Decimal) (int, adapters.Error) <span class="cov8" title="1">{
        var (
                tx    trx.Tx
                txErr error
        )
        defer trx.RollbackTx(tx, txErr)

        // Start transaction
        tx, txErr = wi.txManager.BeginTrx(ctx, nil)
        if txErr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.DefaultError(txErr)
        }</span>

        <span class="cov8" title="1">txWalletRepo := wi.walletRepo.WithTx(tx)

        // Receive source wallet
        sourceWallet, getSourceWalletErr := txWalletRepo.GetByID(ctx, walletFrom)
        if getSourceWalletErr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.NotFound(getSourceWalletErr)
        }</span>

        // Check source wallet balance
        <span class="cov8" title="1">if sourceWallet.Balance.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                return 0, wi.errFactory.DefaultError(fmt.Errorf("source wallet balance is less or equal to zero"))
        }</span>

        // Receive destination wallet
        <span class="cov8" title="1">_, getDestinationWalletErr := txWalletRepo.GetByID(ctx, walletTo)
        if getDestinationWalletErr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.NotFound(getDestinationWalletErr)
        }</span>

        // Perform transfer
        <span class="cov8" title="1">walletSourceID, transferErr := txWalletRepo.Transfer(
                ctx,
                walletFrom,
                walletTo,
                amount,
        )
        if transferErr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.DefaultError(transferErr)
        }</span>

        <span class="cov8" title="1">txWalletOpRepo := wi.operationsManager.WithTx(tx)
        // Create wallet operation instance for deposit
        _, depositOpErrr := txWalletOpRepo.Create(ctx, repositories.Deposit, walletFrom, walletTo, amount)
        if depositOpErrr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.DefaultError(depositOpErrr)
        }</span>

        // Create wallet operation instance for withdrawal
        <span class="cov8" title="1">_, withdrawalOpErrr := txWalletOpRepo.Create(ctx, repositories.Withdrawal, walletTo, walletFrom, amount)
        if withdrawalOpErrr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.DefaultError(withdrawalOpErrr)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">if commitErr := tx.Commit(); commitErr != nil </span><span class="cov8" title="1">{
                return 0, wi.errFactory.DefaultError(commitErr)
        }</span>
        <span class="cov8" title="1">return walletSourceID, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
